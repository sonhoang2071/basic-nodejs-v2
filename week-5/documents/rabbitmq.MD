# RabbitMQ

# 1. Overview

## 1.1 What is RabbitMQ

<aside>
üí° RabbitMQ is [message broker](https://www.ibm.com/topics/message-brokers#:~:text=Message%20brokers%20are%20software%20modules,focus%20on%20its%20core%20logic.) which is is open source code written in Erlang. It using [**AMQP](https://www.rabbitmq.com/tutorials/amqp-concepts)** protocol¬†(**A**dvanced¬†**M**essage¬†**Q**ueuing¬†**P**rotocol).

</aside>

![https://www.cloudamqp.com/img/blog/workflow-rabbitmq.png](https://www.cloudamqp.com/img/blog/workflow-rabbitmq.png)

## 1.2  How does RabbitMQ work?

![https://www.cloudamqp.com/img/blog/rabbitmq-beginners-updated.png](https://www.cloudamqp.com/img/blog/rabbitmq-beginners-updated.png)

The message flow in RabbitMQ works as:

1. The user sends a PDF creation request to the web application.
2. The web application (the producer) sends a message to RabbitMQ that includes data from the request such as name and email.
3. An exchange accepts the messages from the producer and routes them to correct message queues for PDF creation.
4. The PDF processing worker (the consumer) receives the task message and starts processing the PDF.

# 2. Installation

## 2.1 Installation

### 2.1.1 Install on Localhost

- Install Erlang

```bash
sudo apt install -y erlang
```

- Install RabbitMQ

```bash
echo "deb https://dl.bintray.com/rabbitmq/debian $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list
wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -
sudo apt update
sudo apt install rabbitmq-server
```

- Start RabbitMQ service:

```bash
sudo systemctl enable rabbitmq-server
sudo systemctl start rabbitmq-server
```

### 2.1.2 Docker

- Pull image

```bash
docker pull rabbitmq:management
```

- Run image

```bash
docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management
```

### 2.1.3 Cloud Service

<aside>
üí° If you want to use RabbitMQ as a cloud service, [CloudAMQP](https://www.cloudamqp.com/) is a good choice.

</aside>

# 3. How to use RabbitMQ

## 3.1 Connection

- Connection is a TCP connection between your application and the RabbitMQ broker. It represents a continuous trading session between two parties.
- The connection maintains constant communication with RabbitMQ, allowing messages to be sent and received.
- Creating and maintaining a connection is resource intensive (CPU, memory) because it involves many security elements and data flow management.

## 3.2 Channel

- Channel is a virtual connection created within a physical connection. A connection can have many channels.
- Channels allow multiple sessions to be performed simultaneously on a single connection, helping to optimize performance and resources.

## 3.3 Message

<aside>
üí° Message is basic unit to exchange information in RabbitMQ. It includes body(payload) and properties like : header, routing key, messageID, ‚Ä¶

</aside>

### 3.3.1 Message body(payload)

<aside>
üí° Contains the actual data that needs to be sent, which can be in various formats such as JSON, XML, binary or any structure.

</aside>

### 3.3.2 Properties

Message properties are the meta information associated with the message. RabbitMQ supports many properties, including:

- messageId : A unique identifier for the message.
- timestamp : Time when the message was created.
- content Type : The content type of the message (for example, application/json).
- content Encoding : Encoding of the content (e.g. gzip).
- priority : Message priority.
- correlationId : Identifier to link messages together.
- replyTo : Queue address to send response.
- expiration: Message lifetime.
- userId: ID of the user sending the message.
- appId: ID of the application sending the message.
- headers: User-defined custom properties

## 3.4 Queue

A queue in RabbitMQ is a place to store messages waiting to be processed by consumers. Queue is one of the core components of RabbitMQ and has many important properties and configurations. Below are the main elements and properties of a queue in RabbitMQ

### 3.4.1 **Queue Name**

- Each queue must have a unique name within a vhost. The queue name can be set explicitly or automatically generated by RabbitMQ.

### 3.4.2 Durable

- This property determines whether the queue persists after the RabbitMQ server restarts.
- If a queue is durable, it will be stored on disk and survive restarts of RabbitMQ.

### 3.4.3 **Exclusive**

- This property determines whether the queue can be used by only one connection and will be deleted when that connection closes.
- Queue exclusive is often used for temporary, private queues.

### 3.4.4 **Auto-delete**

- This property determines whether the queue is automatically deleted when there are no more consumers subscribed to it.
- Queue auto-delete is useful for applications where queues only need to exist for a short period of time.

### 3.4.5 **Arguments**

- Queue can be configured with additional parameters such as TTL (time-to-live), length limit, and sharding policy.

### 3.4.6 **Bindings**

- Queue must be bound to one or more exchanges. These constraints determine how messages are routed from the exchange to the queue.
- A queue can have many bindings to many different exchanges.

### 3.4.7 **Messages**

- Queue contains messages sent from producers and waiting to be processed by consumers.

## 3.5 Producer

<aside>
üí° Producer is a component in the RabbitMQ system responsible for creating and sending messages to queues via exchange.
The Producer typically opens one or more TCP connections to the exchange during application initialization.

</aside>

### 3.5.1 Producer Work Steps

- **Create connection**
    - The Producer needs to open a TCP connection to the RabbitMQ broker.
- **Create channel**
    - A channel is created in this connection to send messages. A channel is a virtual connection that allows multiple trading sessions on a single connection.
- **Send message**
    - Messages are sent to an exchange, which in turn is routed to queue(s) based on bindings.
- **Routing**
    - Exchange receives the message from the producer and routes it to the appropriate queue(s) based on the routing key.

## 3.6 Binding

Binding in RabbitMQ is a connection between an exchange and a queue. Binding defines how messages are routed from the exchange to the queue. Each binding can have an associated routing key that defines the routing rules of the message.

A queue can be linked to multiple exchanges, and an exchange can have multiple links to different queues.

- Exchange : Is the place to receive messages from the producer.
- Queue: N∆°i l∆∞u tr·ªØ c√°c th√¥ng ƒëi·ªáp ch·ªù ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi c√°c consumer.
- Routing Key: The routing key is used to determine how the exchange routes messages to the queue. This key only applies to direct and topic exchanges.

## 3.7 Exchange

<aside>
üí° Exchange in RabbitMQ is a component responsible for routing messages from producers to appropriate queues. Exchange receives the message from the producer and based on routing and binding rules, it decides which queue to send the message to.

</aside>

![https://www.cloudamqp.com/img/blog/exchanges-bidings-routing-keys.svg](https://www.cloudamqp.com/img/blog/exchanges-bidings-routing-keys.svg)

### 3.7.1 **RabbitMQ message flow**

- The producer publishes a message to the exchange.
- The exchange receives the message and is now responsible for the routing of the message.
- Binding must be set up between the queue and the exchange. In this case, we have bindings to two different queues from the exchange. The exchange routes the message into the queues.
- The messages stay in the queue until they are handled by a consumer.
- The consumer handles the message.

### 3.7.2 **Exchange types**

- **Direct Exchange**

  A direct exchange delivers messages to queues based on a message routing key. The routing key is a message attribute added to the message header by the producer. Think of the routing key as an "address" that the exchange is using to decide how to route the message.¬†**A message goes to the queue(s) with the binding key that exactly matches the routing key of the message.**


![https://www.cloudamqp.com/img/blog/direct-exchange.svg](https://www.cloudamqp.com/img/blog/direct-exchange.svg)

- **Default exchange**

  The default exchange is a pre-declared direct exchange with no name, usually referred by an empty string. When you use default exchange, your message is delivered to the queue with a name equal to the routing key of the message. Every queue is automatically bound to the default exchange with a routing key which is the same as the queue name.

- **Topic Exchange**

  Topic exchanges route messages to queues based on wildcard matches between the routing key and the routing pattern, which is specified by the queue binding. Messages are routed to one or many queues based on a matching between a message routing key and this pattern.

  Allows the use of regular expression patterns in routing keys such as * to represent one character and # to represent zero or more characters.

  ![https://www.cloudamqp.com/img/blog/topic-exchange.svg](https://www.cloudamqp.com/img/blog/topic-exchange.svg)

- **Fanout Exchange**

Broadcast messages to all queues associated with the exchange, regardless of routing key.

![https://www.cloudamqp.com/img/blog/fanout-exchange.svg](https://www.cloudamqp.com/img/blog/fanout-exchange.svg)

- **Headers Exchange**

A headers exchange routes messages based on arguments containing headers and optional values. Headers exchanges are very similar to topic exchanges, but route messages based on header values instead of routing keys. A message matches if the value of the header equals the value specified upon binding.

Example: Messages with header {type: 'log', level: 'info'} will be routed to a queue that has a binding requesting header with {type: 'log', level: 'info'}.

![https://www.cloudamqp.com/img/blog/rabbitmq-headers-exchange.svg](https://www.cloudamqp.com/img/blog/rabbitmq-headers-exchange.svg)

## 3.8 Consumer

Consumer is the component in the RabbitMQ system responsible for receiving and processing messages from queues. The consumer registers with RabbitMQ and listens for messages sent to the queue it is interested in. When there is a new message, RabbitMQ will send that message to the consumer for processing

### 3.8.1 Work flow

When a new message arrives in the queue, the consumer will consume the message through two operating mechanisms:

- Push: is the default operating mode, RabbitMQ will push messages to consumers
- Pull: consumers actively poll messages from the queue

### **Push (Basic.Consume)**

In the push mechanism, RabbitMQ pushes messages to consumers whenever there is a new message in the queue. Thanks to this, the client receives real-time or near real-time data with low latency and reacts to changes instantly.

Because RabbitMQ is a message broker whose main purpose is to ensure that messages are delivered to consumers as quickly and efficiently as possible, push becomes the default mode of operation in RabbitMQ.

However, because RabbitMQ controls the data transfer rate, the push mechanism has difficulty handling when consumers have different consumption rates. In addition, the push mechanism only works when a bidirectional connection between the client and server is established. If the client is disconnected when the server pushes the response, the response may be lost.

### **Pull (Basic.Get)**

In pull mode, consumers actively poll messages from the queue.

The consumer sends a Basic.Get request to RabbitMQ when it is ready to process the message. RabbitMQ will resend messages from the queue if possible.

Pull mode is suitable for cases where consumers want to retrieve messages on demand instead of continuously being pushed messages.

Pull mode can be less effective than push mode especially if the polling frequency is not well adjusted. If consumers frequently poll when there are no messages in the queue, it will lead to a waste of resources. If consumers poll less, their idle time may increase.

## 3.8.2 **Delivery acknowledgment mode**

Consumers can choose between two delivery acknowledgment modes so that the queue knows how to handle messages sent to consumers:

- Automatic: does not require consumer confirmation, also known as "fire and forget‚Äù
- Manual: requires consumer confirmation

# 4. How to manage RabbitMQ

## 4.1 Command Line Tools

RabbitMQ ships with multiple command line tools, each with a set of related commands:

- [rabbitmqctl](https://www.rabbitmq.com/docs/man/rabbitmqctl.8)¬†for service management and general operator tasks
- [rabbitmq-diagnostics](https://www.rabbitmq.com/docs/man/rabbitmq-diagnostics.8)¬†for diagnostics and¬†[health checking](https://www.rabbitmq.com/docs/monitoring)
- [rabbitmq-plugins](https://www.rabbitmq.com/docs/man/rabbitmq-plugins.8)¬†for¬†[plugin management](https://www.rabbitmq.com/docs/plugins)
- [rabbitmq-queues](https://www.rabbitmq.com/docs/man/rabbitmq-queues.8)¬†for maintenance tasks on¬†[queues](https://www.rabbitmq.com/docs/queues), in particular¬†[quorum queues](https://www.rabbitmq.com/docs/quorum-queues)
- [rabbitmq-streams](https://www.rabbitmq.com/docs/man/rabbitmq-streams.8)¬†for maintenance tasks on¬†[streams](https://www.rabbitmq.com/docs/streams)
- [rabbitmq-upgrade](https://www.rabbitmq.com/docs/man/rabbitmq-upgrade.8)¬†for maintenance tasks related to¬†[upgrades](https://www.rabbitmq.com/docs/upgrade)

### 4.1.1 **rabbitmqctl**

[rabbitmqctl](https://www.rabbitmq.com/docs/man/rabbitmqctl.8)¬†is the original CLI tool that ships with RabbitMQ. It supports a wide range of operations, mostly administrative (operational) in nature.

This includes

- Stopping node
- Access to node status, effective configuration, health checks
- Virtual host management
- User and permission management
- Policy management
- Listing queues, connections, channels, exchanges, consumers
- Cluster membership management

## 4.2 **Configuration**

RabbitMQ comes with default built-in settings. Those can be entirely sufficient in some environment (e.g. development and QA). For all other cases, as well as¬†[production deployment tuning](https://www.rabbitmq.com/docs/production-checklist), there is a way to configure many things in the broker as well as¬†[plugins](https://www.rabbitmq.com/docs/plugins).

This guide covers a number of topics related to configuration:

- [Different ways](https://www.rabbitmq.com/docs/configure#means-of-configuration)¬†in which various settings of the server and plugins are configured
- [Configuration file(s)](https://www.rabbitmq.com/docs/configure#configuration-files): primary¬†[rabbitmq.conf](https://www.rabbitmq.com/docs/configure#config-file)¬†or¬†[a directory of .conf files](https://www.rabbitmq.com/docs/configure#config-confd-directory), and optional¬†[advanced.config](https://www.rabbitmq.com/docs/configure#advanced-config-file)
- Default¬†[configuration file location(s)](https://www.rabbitmq.com/docs/configure#config-location)¬†on various platforms
- Configuration troubleshooting: how to¬†[find config file location](https://www.rabbitmq.com/docs/configure#verify-configuration-config-file-location)¬†and¬†[inspect and verify effective configuration](https://www.rabbitmq.com/docs/configure#verify-configuration-effective-configuration)
- [Environment variable interpolation](https://www.rabbitmq.com/docs/configure#env-variable-interpolation)¬†in¬†rabbitmq.conf
- [Environment variables](https://www.rabbitmq.com/docs/configure#customise-environment)¬†used by RabbitMQ nodes
- [Operating system (kernel) limits](https://www.rabbitmq.com/docs/configure#kernel-limits)
- Available¬†[core server settings](https://www.rabbitmq.com/docs/configure#config-items)
- Available¬†[environment variables](https://www.rabbitmq.com/docs/configure#supported-environment-variables)
- How to¬†[encrypt sensitive configuration values](https://www.rabbitmq.com/docs/configure#configuration-encryption)

## 4.3 Logging

Log files is a very important aspect of system observability, much like¬†[monitoring](https://www.rabbitmq.com/docs/monitoring).

Developers and operators should inspect logs when troubleshooting an issue or assessing the state of the system.

RabbitMQ supports a number of features when it comes to logging.

This guide covers topics such as:

- Supported¬†[log outputs](https://www.rabbitmq.com/docs/logging#log-outputs):¬†[file](https://www.rabbitmq.com/docs/logging#logging-to-a-file)¬†and¬†[standard streams (console)](https://www.rabbitmq.com/docs/logging#logging-to-console)
- [Log file location](https://www.rabbitmq.com/docs/logging#log-file-location)
- Supported¬†[log levels](https://www.rabbitmq.com/docs/logging#log-levels)
- How to¬†[activate debug logging](https://www.rabbitmq.com/docs/logging#debug-logging)
- How to¬†[tail logs of a running node](https://www.rabbitmq.com/docs/logging#log-tail)¬†without having access to the log file
- Watching¬†[internal events](https://www.rabbitmq.com/docs/logging#internal-events)
- [Connection lifecycle events](https://www.rabbitmq.com/docs/logging#logged-events)¬†logged
- [Logging in JSON](https://www.rabbitmq.com/docs/logging#json)
- [Log categories](https://www.rabbitmq.com/docs/logging#log-message-categories)
- How to¬†[inspect service logs](https://www.rabbitmq.com/docs/logging#service-logs)¬†on systemd-based Linux systems
- [Log rotation](https://www.rabbitmq.com/docs/logging#log-rotation)
- [Logging to Syslog](https://www.rabbitmq.com/docs/logging#logging-to-syslog)
- [Logging to a system topic exchange](https://www.rabbitmq.com/docs/logging#log-exchange)

## 4.4 **Virtual Hosts**

RabbitMQ is multi-tenant system: connections, exchanges, queues, bindings, user permissions, policies and some other things belong to¬†**virtual hosts**, logical groups of entities. If you are familiar with¬†[virtual hosts in Apache](https://httpd.apache.org/docs/2.4/vhosts/)¬†or¬†[server blocks in Nginx](https://www.nginx.com/resources/wiki/start/topics/examples/server_blocks/), the idea is similar.

There is, however, one important difference: virtual hosts in Apache are defined in the configuration file; that's not the case with RabbitMQ: virtual hosts are¬†[created](https://www.rabbitmq.com/docs/vhosts#creating)¬†and¬†[deleted](https://www.rabbitmq.com/docs/vhosts#deleting)¬†using¬†**rabbitmqctl**¬†or the HTTP API instead.

### 4.4.1 **Creating a Virtual Host**

A virtual host can be created using¬†[rabbitmqctl](https://www.rabbitmq.com/docs/cli)'s¬†**add_vhost**¬†command which accepts virtual host name as the only mandatory argument.

Here's an example that creates a virtual host named¬†**qa1**:

```bash
rabbitmqctl add_vhost qa1
```

### 4.4.2 **Virtual Host Metadata**

Virtual hosts can have metadata associated with them:

- A description
- A set of tags
- Default queue type configured for the virtual host

All these settings are optional. They can be provided at virtual host creation time or updated later.

- rabbitmqctl add_vhost

```bash
rabbitmqctl add_vhost qa1 --description "QA environment 1" --default-queue-type quorum --tags qa,project-a
```

- rabbitmqctl update_vhost_metadata

```bash
rabbitmqctl update_vhost_metadata qa1 --description "QA environment for issue 1662" --default-queue-type quorum --tags qa,project-a,qa-1662
```

- rabbitmqctl list_vhosts

```bash
rabbitmqctl -q --formatter=pretty_table list_vhosts name description tags default_queue_type
```

### 4.4.3 Deleting a Virtual Host

```bash
rabbitmqctl delete_vhost qa1
```

### 4.4.4 **Configuring Max Connection Limit**

```bash
rabbitmqctl set_vhost_limits -p vhost_name '{"max-connections": 256}'
```

### 4.4.5 **Configuring Max Number of Queues**

```bash
rabbitmqctl set_vhost_limits -p vhost_name '{"max-queues": 1024}'
```

# 5. How to monitor RabbitMQ

This document provides an overview of topics related to RabbitMQ monitoring. Monitoring RabbitMQ and applications that use it is critically important. Monitoring helps detect issues before they affect the rest of the environment and, eventually, the end users.

The combination of¬†[Prometheus and Grafana](https://www.rabbitmq.com/docs/prometheus)¬†is the highly recommended option for RabbitMQ monitoring.

RabbitMQ monitoring with two popular tools:¬†[Prometheus](https://prometheus.io/docs/introduction/overview/), a monitoring toolkit; and¬†[Grafana](https://grafana.com/grafana), a metrics visualisation system.

These tools together form a powerful toolkit for long-term metric collection and monitoring of RabbitMQ clusters. While¬†[RabbitMQ management UI](https://www.rabbitmq.com/docs/management)¬†also provides access to a subset of metrics, it by design doesn't try to be a long term metric collection solution.

Please read through the main¬†[guide on monitoring](https://www.rabbitmq.com/docs/monitoring)¬†first. Monitoring principles and available metrics are mostly relevant when Prometheus and Grafana are used.

### Built-in Prometheus Support[](https://www.rabbitmq.com/docs/prometheus#overview-prometheus)

RabbitMQ ships with built-in Prometheus & Grafana support.

Support for Prometheus metric collector ships in the¬†`rabbitmq_prometheus`¬†plugin. The plugin exposes all RabbitMQ metrics on a dedicated TCP port, in Prometheus text format.

These metrics provide deep insights into the state of RabbitMQ nodes and¬†[the runtime](https://www.rabbitmq.com/docs/runtime). They make reasoning about the behaviour of RabbitMQ, applications that use it and various infrastructure elements a lot more informed.